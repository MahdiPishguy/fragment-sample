import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/material.dart';
import 'package:kelide_jazzb/database/app_database.dart';
import 'package:kelide_jazzb/database/sqf_entity_base.dart';

/*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following:
      - import Lesson.dart into where to use
      - start typing Lesson().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(lesson) / or toList(lessonList)
      - you can select one Lesson or List<Lesson> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
// region Lesson
class Lesson {
  // FIELDS
  int id;
  String title;
  String content;
  String file_url;
  String filename;
  String time;
  int media;
  int key;
  bool download_complete;
  int month_sectionId;
  // end FIELDS

// RELATIONSHIPS
  getMonth_section(VoidCallback month_section(Month_section o)) {
    Month_section().getById(month_sectionId, (obj) {
      month_section(obj); return;
    });
  }
  // END RELATIONSHIPS


  static const bool _softDeleteActivated=false;
  LessonManager __mnLesson;
  LessonFilterBuilder _select;

  LessonManager get _mnLesson {
    if (__mnLesson == null) __mnLesson = new LessonManager();
    return __mnLesson;
  }

  Lesson({this.id, this.title,this.content,this.file_url,this.filename,this.time,this.media,this.key,this.download_complete,this.month_sectionId}) { setDefaultValues();}
  Lesson.withFields(this.title,this.content,this.file_url,this.filename,this.time,this.media,this.key,this.download_complete,this.month_sectionId){ setDefaultValues();}
  Lesson.withId(this.id, this.title,this.content,this.file_url,this.filename,this.time,this.media,this.key,this.download_complete,this.month_sectionId){ setDefaultValues();}

  // methods
  Map<String, dynamic> toMap({bool forQuery=false}) {
    var map = Map<String, dynamic>();
    if (id != null) map["id"] = id;    if (title != null) map["title"] = title;
    if (content != null) map["content"] = content;
    if (file_url != null) map["file_url"] = file_url;
    if (filename != null) map["filename"] = filename;
    if (time != null) map["time"] = time;
    if (media != null) map["media"] = media;
    if (key != null) map["key"] = key;
    if (download_complete != null) map["download_complete"] = forQuery? (download_complete ? 1 : 0) : download_complete;
    if (month_sectionId != null) map["month_sectionId"] = month_sectionId;

    return map;
  }

  Lesson.fromMap(Map<String, dynamic> o) {
    this.id = o["id"];
    this.title = o["title"];
    this.content = o["content"];
    this.file_url = o["file_url"];
    this.filename = o["filename"];
    this.time = o["time"];
    this.media = o["media"];
    this.key = o["key"];
    this.download_complete = o["download_complete"] != null ? o["download_complete"] == 1 : null;
    this.month_sectionId = o["month_sectionId"];

  }

  List<dynamic> toArgs() {
    return[id,title,content,file_url,filename,time,media,key,download_complete,month_sectionId];
  }


  static fromWebUrl(String url, VoidCallback  lessonList (List<Lesson> o)) async {
    var objList = List<Lesson>();
    http.get(url).then((response) {
      Iterable list = json.decode(response.body);
      try {
        objList = list.map((lesson) => Lesson.fromMap(lesson)).toList();
        lessonList(objList); return;
      } catch (e) {
        print("SQFENTITY ERROR Lesson.fromWeb: ErrorMessage:" + e.toString());
      }
    });
  }

  static Future<List<Lesson>> fromObjectList(Future<List<dynamic>> o) async {
    var lessonsList = new List<Lesson>();
    o.then((data) {
      for (int i = 0; i < data.length; i++) {
        lessonsList.add(Lesson.fromMap(data[i]));
      }
    });
    return lessonsList;
  }

  static List<Lesson> fromMapList(List<Map<String, dynamic>> query) {
    List<Lesson> lessons = List<Lesson>();
    for (Map map in query) {
      lessons.add(Lesson.fromMap(map));
    }
    return lessons;
  }

  /// returns Lesson by ID if exist, otherwise returns null
  /// <param name="id">Primary Key Value</param>
  /// <returns>returns Lesson if exist, otherwise returns null</returns>
  getById(int id, VoidCallback lesson(Lesson o)) {
    Lesson lessonObj;
    var lessonFuture = _mnLesson.getById(id);
    lessonFuture.then((data) {
      if (data.length > 0)
        lessonObj = Lesson.fromMap(data[0]);
      else
        lessonObj = null;
      lesson(lessonObj);
    });
  }

  /// <summary>
  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> save() async {
    if (id == null || id == 0)
      id = await _mnLesson.insert(
          Lesson.withFields(title,content,file_url,filename,time,media,key,download_complete,month_sectionId));
    else
      id= await _upsert();
    return id;
  }

  /// <summary>
  /// saveAll method saves the sent List<Lesson> as a batch in one transaction
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> saveAll(List<Lesson> lessons) async {
    var results = _mnLesson.saveAll("INSERT OR REPLACE INTO lessons (id, title,content,file_url,filename,time,media,key,download_complete,month_sectionId)  VALUES (?,?,?,?,?,?,?,?,?,?)",lessons);
    return results;
  }

  /// <summary>
  /// Updates if the record exists, otherwise adds a new row
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> _upsert() async {
    id = await _mnLesson.rawInsert(
        "INSERT OR REPLACE INTO lessons (id, title,content,file_url,filename,time,media,key,download_complete,month_sectionId)  VALUES (?,?,?,?,?,?,?,?,?,?)", [id,title,content,file_url,filename,time,media,key,download_complete,month_sectionId]);
    return id;
  }


  /// <summary>
  /// inserts or replaces the sent List<Todo> as a batch in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> upsertAll(List<Lesson> lessons) async {
    var results = await _mnLesson.rawInsertAll(
        "INSERT OR REPLACE INTO lessons (id, title,content,file_url,filename,time,media,key,download_complete,month_sectionId)  VALUES (?,?,?,?,?,?,?,?,?,?)", lessons);
    return results;
  }


  /// <summary>
  /// saveAs Lesson. Returns a new Primary Key value of Lesson
  /// </summary>
  /// <returns>Returns a new Primary Key value of Lesson</returns>
  Future<int> saveAs() async {
    id = await _mnLesson.insert(
        Lesson.withFields(title,content,file_url,filename,time,media,key,download_complete,month_sectionId));
    return id;
  }


  /// <summary>
  /// Deletes Lesson
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    print("SQFENTITIY: delete Lesson invoked (id=$id)");
    if (!_softDeleteActivated)
      return _mnLesson.delete(QueryParams(whereString: "id=$id"));
    else
      return _mnLesson.updateBatch(QueryParams(whereString: "id=$id"), {"isDeleted": 1});
  }

  //private LessonFilterBuilder _Select;
  LessonFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    _select = new LessonFilterBuilder(this);
    _select._getIsDeleted = getIsDeleted==true;
    _select.qparams.selectColumns = columnsToSelect;
    return _select;
  }

  LessonFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    LessonFilterBuilder _distinct = new LessonFilterBuilder(this);
    _distinct._getIsDeleted = getIsDeleted==true;
    _distinct.qparams.selectColumns = columnsToSelect;
    _distinct.qparams.distinct = true;
    return _distinct;
  }

  void setDefaultValues() {
    if(download_complete==null) download_complete=false;

  }
//end methods
}
// endregion lesson


// region LessonField
class LessonField extends SearchCriteria {
  DbParameter param;
  String _waitingNot = "";
  LessonFilterBuilder lessonFB;
  LessonField(LessonFilterBuilder fb) {
    param = new DbParameter();
    lessonFB = fb;
  }
  LessonField get not {
    _waitingNot = " NOT ";
    return this;
  }
  LessonFilterBuilder equals(var pValue) {
    param.expression = "=";
    lessonFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, lessonFB.parameters, param, SqlSyntax.EQuals,
        lessonFB._addedBlocks)
        : setCriteria(pValue, lessonFB.parameters, param, SqlSyntax.NotEQuals,
        lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder isNull() {
    lessonFB._addedBlocks = setCriteria(
        0,
        lessonFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder contains(dynamic pValue) {
    lessonFB._addedBlocks = setCriteria(
        "%" + pValue + "%",
        lessonFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder startsWith(dynamic pValue) {
    lessonFB._addedBlocks = setCriteria(
        pValue + "%",
        lessonFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder endsWith(dynamic pValue) {
    lessonFB._addedBlocks = setCriteria(
        "%" + pValue,
        lessonFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      lessonFB._addedBlocks = setCriteria(
          pFirst,
          lessonFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          lessonFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "")
        lessonFB._addedBlocks = setCriteria(pFirst, lessonFB.parameters,
            param, SqlSyntax.LessThan, lessonFB._addedBlocks);
      else
        lessonFB._addedBlocks = setCriteria(pFirst, lessonFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, lessonFB._addedBlocks);
    } else if (pLast != null) {
      if (_waitingNot != "")
        lessonFB._addedBlocks = setCriteria(pLast, lessonFB.parameters, param,
            SqlSyntax.GreaterThan, lessonFB._addedBlocks);
      else
        lessonFB._addedBlocks = setCriteria(pLast, lessonFB.parameters, param,
            SqlSyntax.LessThanOrEquals, lessonFB._addedBlocks);
    }
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    lessonFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, lessonFB.parameters, param,
        SqlSyntax.GreaterThan, lessonFB._addedBlocks)
        : setCriteria(pValue, lessonFB.parameters, param,
        SqlSyntax.LessThanOrEquals, lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    lessonFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, lessonFB.parameters, param, SqlSyntax.LessThan,
        lessonFB._addedBlocks)
        : setCriteria(pValue, lessonFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    lessonFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, lessonFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, lessonFB._addedBlocks)
        : setCriteria(pValue, lessonFB.parameters, param, SqlSyntax.LessThan,
        lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    lessonFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, lessonFB.parameters, param,
        SqlSyntax.LessThanOrEquals, lessonFB._addedBlocks)
        : setCriteria(pValue, lessonFB.parameters, param,
        SqlSyntax.GreaterThan, lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
  LessonFilterBuilder inValues(var pValue) {
    lessonFB._addedBlocks = setCriteria(
        pValue,
        lessonFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        lessonFB._addedBlocks);
    _waitingNot = "";
    lessonFB._addedBlocks.needEndBlock[lessonFB._blockIndex] =
        lessonFB._addedBlocks.retVal;
    return lessonFB;
  }
}
// endregion LessonField

// region LessonFilterBuilder
class LessonFilterBuilder extends SearchCriteria {
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Lesson _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;
  LessonFilterBuilder(Lesson obj) {
    whereString = "";
    qparams = new QueryParams();
    parameters = List<DbParameter>();
    orderByList = List<String>();
    groupByList = List<String>();
    _addedBlocks = new AddedBlocks(new List<bool>(), new List<bool>());
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }

  LessonFilterBuilder get and {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " AND ";
    return this;
  }

  LessonFilterBuilder get or {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " OR ";
    return this;
  }

  LessonFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  LessonFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != "") {
      DbParameter param = new DbParameter();
      _addedBlocks = setCriteria(
          0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  LessonFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  LessonFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  LessonFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += " ) ";
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  LessonFilterBuilder orderBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add(argFields);
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s ");
        }
    }
    return this;
  }

  LessonFilterBuilder orderByDesc(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add("$argFields desc ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s desc ");
        }
    }
    return this;
  }

  LessonFilterBuilder groupBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.groupByList.add(" $argFields ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.groupByList.add(" $s ");
        }
    }
    return this;
  }

  LessonField setField(LessonField field, String colName, DbType dbtype) {
    field = new LessonField(this);
    field.param = new DbParameter(
        dbType: dbtype,
        columnName: colName,
        wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
    return field;
  }

  LessonField _id;
  LessonField get id {
    _id = setField(_id, "id", DbType.integer);
    return _id;
  }
  LessonField _title;
  LessonField get title {
    _title = setField(_title, "title", DbType.text);
    return _title;
  }
  LessonField _content;
  LessonField get content {
    _content = setField(_content, "content", DbType.text);
    return _content;
  }
  LessonField _file_url;
  LessonField get file_url {
    _file_url = setField(_file_url, "file_url", DbType.text);
    return _file_url;
  }
  LessonField _filename;
  LessonField get filename {
    _filename = setField(_filename, "filename", DbType.text);
    return _filename;
  }
  LessonField _time;
  LessonField get time {
    _time = setField(_time, "time", DbType.text);
    return _time;
  }
  LessonField _media;
  LessonField get media {
    _media = setField(_media, "media", DbType.integer);
    return _media;
  }
  LessonField _key;
  LessonField get key {
    _key = setField(_key, "key", DbType.integer);
    return _key;
  }
  LessonField _download_complete;
  LessonField get download_complete {
    _download_complete = setField(_download_complete, "download_complete", DbType.bool);
    return _download_complete;
  }
  LessonField _month_sectionId;
  LessonField get month_sectionId {
    _month_sectionId = setField(_month_sectionId, "month_sectionId", DbType.integer);
    return _month_sectionId;
  }


  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams.limit = _pagesize;
      qparams.offset = (_page - 1) * _pagesize;
    } else {
      qparams.limit = _pagesize;
      qparams.offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll("[", "")
              .replaceAll("]", "")
              .toString();
          whereString += param.whereString
              .replaceAll("{field}", param.columnName)
              .replaceAll("?", param.value);
          param.value = null;
        } else
          whereString +=
              param.whereString.replaceAll("{field}", param.columnName);
        switch (param.dbType) {
          case DbType.bool:
            if (param.value != null) param.value = param.value ? 1 : 0;
            break;
          default:
        }

        if (param.value != null) whereArguments.add(param.value);
        if (param.value2 != null) whereArguments.add(param.value2);
      } else
        whereString += param.whereString;
    }
    if (Lesson._softDeleteActivated) {
      if (whereString != "")
        whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
            " ($whereString)";
      else if (!_getIsDeleted) whereString = "ifnull(isDeleted,0)=0";
    }

    if (whereString != "") qparams.whereString = whereString;
    qparams.whereArguments = whereArguments;
    qparams.groupBy = groupByList.join(',');
    qparams.orderBy = orderByList.join(',');
  }


  /// <summary>
  /// Deletes List<Lesson> batch by query
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    _buildParameters();
    var r= BoolResult();
    if(Lesson._softDeleteActivated)
      r = await _obj._mnLesson.updateBatch(qparams,{"isDeleted":1});
    else
      r = await _obj._mnLesson.delete(qparams);
    return r;
  }


  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    return _obj._mnLesson.updateBatch(qparams, values);
  }

  /// This method always returns LessonObj if exist, otherwise returns null
  /// <returns>List<Lesson></returns>
  void toSingle(VoidCallback lesson(Lesson o)) {
    _pagesize = 1;
    _buildParameters();
    var objFuture = _obj._mnLesson.toList(qparams);
    objFuture.then((data) {
      if (data.length > 0)
        lesson(Lesson.fromMap(data[0]));
      else
        lesson(null);
    });
  }


  /// This method always returns int.
  /// <returns>int</returns>
  Future<BoolResult> toCount(VoidCallback lessonCount (int c)) async {
    _buildParameters();
    qparams.selectColumns = ["COUNT(1) AS CNT"];
    var lessonsFuture = await _obj._mnLesson.toList(qparams);
    int count = lessonsFuture[0]["CNT"];
    lessonCount (count);
    return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
  }

  /// This method always returns List<Lesson>.
  /// <returns>List<Lesson></returns>
  void toList(VoidCallback lessonList (List<Lesson> o)) async {

    _buildParameters();

    var lessonsFuture = _obj._mnLesson.toList(qparams);

    List<Lesson> lessonsData = new List<Lesson>();
    lessonsFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        lessonsData.add(Lesson.fromMap(data[i]));
      }
      lessonList (lessonsData);
      lessonsData = null;
    });
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int></returns>
  Future<List<int>> toListPrimaryKey(VoidCallback idList (List<int> o),
      [bool buildParameters=true]) async {
    if(buildParameters) _buildParameters();
    List<int> idData = new List<int>();
    qparams.selectColumns= ["id"];
    var idFuture = await _obj._mnLesson.toList(qparams);

    int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]["id"]);
    }
    idList (idData);
    return idData;
  }

  void toListObject(VoidCallback listObject(List<dynamic> o)) async {
    _buildParameters();

    var objectFuture = _obj._mnLesson.toList(qparams);

    List<dynamic> objectsData = new List<dynamic>();
    objectFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        objectsData.add(data[i]);
      }
      listObject(objectsData);
      objectsData = null;
    });


  }

}
// endregion LessonFilterBuilder




// region LessonFields
class LessonFields {
  static TableField _fId;
  static TableField get id {
    _fId = SqlSyntax.setField(_fId, "id", DbType.integer);
    return _fId;
  }
  static TableField _fTitle;
  static TableField get title {
    _fTitle = SqlSyntax.setField(_fTitle, "title", DbType.text);
    return _fTitle;
  }
  static TableField _fContent;
  static TableField get content {
    _fContent = SqlSyntax.setField(_fContent, "content", DbType.text);
    return _fContent;
  }
  static TableField _fFile_url;
  static TableField get file_url {
    _fFile_url = SqlSyntax.setField(_fFile_url, "file_url", DbType.text);
    return _fFile_url;
  }
  static TableField _fFilename;
  static TableField get filename {
    _fFilename = SqlSyntax.setField(_fFilename, "filename", DbType.text);
    return _fFilename;
  }
  static TableField _fTime;
  static TableField get time {
    _fTime = SqlSyntax.setField(_fTime, "time", DbType.text);
    return _fTime;
  }
  static TableField _fMedia;
  static TableField get media {
    _fMedia = SqlSyntax.setField(_fMedia, "media", DbType.integer);
    return _fMedia;
  }
  static TableField _fKey;
  static TableField get key {
    _fKey = SqlSyntax.setField(_fKey, "key", DbType.integer);
    return _fKey;
  }
  static TableField _fDownload_complete;
  static TableField get download_complete {
    _fDownload_complete = SqlSyntax.setField(_fDownload_complete, "download_complete", DbType.bool);
    return _fDownload_complete;
  }
  static TableField _fMonth_sectionId;
  static TableField get month_sectionId {
    _fMonth_sectionId = SqlSyntax.setField(_fMonth_sectionId, "month_sectionId", DbType.integer);
    return _fMonth_sectionId;
  }

}
// endregion LessonFields

//region LessonManager
class LessonManager extends SqfEntityProvider {
  static String _tableName = "lessons";
  static String _colId = "id";
  LessonManager():super(AppDatabase(),tableName: _tableName, colId: _colId);
}
//endregion LessonManager


/*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following:
      - import Month_section.dart into where to use
      - start typing Month_section().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(month_section) / or toList(month_sectionList)
      - you can select one Month_section or List<Month_section> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
// region Month_section
class Month_section {
  // FIELDS
  int id;
  String month_title;
  String month_description;
  String price;
  String key;
  // end FIELDS


// COLLECTIONS
  getLessons(VoidCallback lessonList(List<Lesson> o)) {
    Lesson().select().month_sectionId.equals(id).toList((objList) {
      lessonList(objList); return;
    });
  }
  // END COLLECTIONS

  static const bool _softDeleteActivated=false;
  Month_sectionManager __mnMonth_section;
  Month_sectionFilterBuilder _select;

  Month_sectionManager get _mnMonth_section {
    if (__mnMonth_section == null) __mnMonth_section = new Month_sectionManager();
    return __mnMonth_section;
  }

  Month_section({this.id, this.month_title,this.month_description,this.price,this.key}) { setDefaultValues();}
  Month_section.withFields(this.month_title,this.month_description,this.price,this.key){ setDefaultValues();}
  Month_section.withId(this.id, this.month_title,this.month_description,this.price,this.key){ setDefaultValues();}

  // methods
  Map<String, dynamic> toMap({bool forQuery=false}) {
    var map = Map<String, dynamic>();
    if (id != null) map["id"] = id;    if (month_title != null) map["month_title"] = month_title;
    if (month_description != null) map["month_description"] = month_description;
    if (price != null) map["price"] = price;
    if (key != null) map["key"] = key;

    return map;
  }

  Month_section.fromMap(Map<String, dynamic> o) {
    this.id = o["id"];
    this.month_title = o["month_title"];
    this.month_description = o["month_description"];
    this.price = o["price"];
    this.key = o["key"];

  }

  List<dynamic> toArgs() {
    return[id,month_title,month_description,price,key];
  }


  static fromWebUrl(String url, VoidCallback  month_sectionList (List<Month_section> o)) async {
    var objList = List<Month_section>();
    http.get(url).then((response) {
      Iterable list = json.decode(response.body);
      try {
        objList = list.map((month_section) => Month_section.fromMap(month_section)).toList();
        month_sectionList(objList); return;
      } catch (e) {
        print("SQFENTITY ERROR Month_section.fromWeb: ErrorMessage:" + e.toString());
      }
    });
  }

  static Future<List<Month_section>> fromObjectList(Future<List<dynamic>> o) async {
    var month_sectionsList = new List<Month_section>();
    o.then((data) {
      for (int i = 0; i < data.length; i++) {
        month_sectionsList.add(Month_section.fromMap(data[i]));
      }
    });
    return month_sectionsList;
  }

  static List<Month_section> fromMapList(List<Map<String, dynamic>> query) {
    List<Month_section> month_sections = List<Month_section>();
    for (Map map in query) {
      month_sections.add(Month_section.fromMap(map));
    }
    return month_sections;
  }

  /// returns Month_section by ID if exist, otherwise returns null
  /// <param name="id">Primary Key Value</param>
  /// <returns>returns Month_section if exist, otherwise returns null</returns>
  getById(int id, VoidCallback month_section(Month_section o)) {
    Month_section month_sectionObj;
    var month_sectionFuture = _mnMonth_section.getById(id);
    month_sectionFuture.then((data) {
      if (data.length > 0)
        month_sectionObj = Month_section.fromMap(data[0]);
      else
        month_sectionObj = null;
      month_section(month_sectionObj);
    });
  }

  /// <summary>
  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> save() async {
    if (id == null || id == 0)
      id = await _mnMonth_section.insert(
          Month_section.withFields(month_title,month_description,price,key));
    else
      id= await _upsert();
    return id;
  }

  /// <summary>
  /// saveAll method saves the sent List<Month_section> as a batch in one transaction
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> saveAll(List<Month_section> month_sections) async {
    var results = _mnMonth_section.saveAll("INSERT OR REPLACE INTO month_section (id, month_title,month_description,price,key)  VALUES (?,?,?,?,?)",month_sections);
    return results;
  }

  /// <summary>
  /// Updates if the record exists, otherwise adds a new row
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> _upsert() async {
    id = await _mnMonth_section.rawInsert(
        "INSERT OR REPLACE INTO month_section (id, month_title,month_description,price,key)  VALUES (?,?,?,?,?)", [id,month_title,month_description,price,key]);
    return id;
  }


  /// <summary>
  /// inserts or replaces the sent List<Todo> as a batch in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> upsertAll(List<Month_section> month_sections) async {
    var results = await _mnMonth_section.rawInsertAll(
        "INSERT OR REPLACE INTO month_section (id, month_title,month_description,price,key)  VALUES (?,?,?,?,?)", month_sections);
    return results;
  }


  /// <summary>
  /// saveAs Month_section. Returns a new Primary Key value of Month_section
  /// </summary>
  /// <returns>Returns a new Primary Key value of Month_section</returns>
  Future<int> saveAs() async {
    id = await _mnMonth_section.insert(
        Month_section.withFields(month_title,month_description,price,key));
    return id;
  }


  /// <summary>
  /// Deletes Month_section
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    print("SQFENTITIY: delete Month_section invoked (id=$id)");
    var result= BoolResult();  result = await Lesson().select().month_sectionId.equals(id).delete();
    if (!result.success) return result;
    else
    if (!_softDeleteActivated)
      return _mnMonth_section.delete(QueryParams(whereString: "id=$id"));
    else
      return _mnMonth_section.updateBatch(QueryParams(whereString: "id=$id"), {"isDeleted": 1});
  }

  //private Month_sectionFilterBuilder _Select;
  Month_sectionFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    _select = new Month_sectionFilterBuilder(this);
    _select._getIsDeleted = getIsDeleted==true;
    _select.qparams.selectColumns = columnsToSelect;
    return _select;
  }

  Month_sectionFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    Month_sectionFilterBuilder _distinct = new Month_sectionFilterBuilder(this);
    _distinct._getIsDeleted = getIsDeleted==true;
    _distinct.qparams.selectColumns = columnsToSelect;
    _distinct.qparams.distinct = true;
    return _distinct;
  }

  void setDefaultValues() {

  }
//end methods
}
// endregion month_section


// region Month_sectionField
class Month_sectionField extends SearchCriteria {
  DbParameter param;
  String _waitingNot = "";
  Month_sectionFilterBuilder month_sectionFB;
  Month_sectionField(Month_sectionFilterBuilder fb) {
    param = new DbParameter();
    month_sectionFB = fb;
  }
  Month_sectionField get not {
    _waitingNot = " NOT ";
    return this;
  }
  Month_sectionFilterBuilder equals(var pValue) {
    param.expression = "=";
    month_sectionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, month_sectionFB.parameters, param, SqlSyntax.EQuals,
        month_sectionFB._addedBlocks)
        : setCriteria(pValue, month_sectionFB.parameters, param, SqlSyntax.NotEQuals,
        month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder isNull() {
    month_sectionFB._addedBlocks = setCriteria(
        0,
        month_sectionFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder contains(dynamic pValue) {
    month_sectionFB._addedBlocks = setCriteria(
        "%" + pValue + "%",
        month_sectionFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder startsWith(dynamic pValue) {
    month_sectionFB._addedBlocks = setCriteria(
        pValue + "%",
        month_sectionFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder endsWith(dynamic pValue) {
    month_sectionFB._addedBlocks = setCriteria(
        "%" + pValue,
        month_sectionFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      month_sectionFB._addedBlocks = setCriteria(
          pFirst,
          month_sectionFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          month_sectionFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "")
        month_sectionFB._addedBlocks = setCriteria(pFirst, month_sectionFB.parameters,
            param, SqlSyntax.LessThan, month_sectionFB._addedBlocks);
      else
        month_sectionFB._addedBlocks = setCriteria(pFirst, month_sectionFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, month_sectionFB._addedBlocks);
    } else if (pLast != null) {
      if (_waitingNot != "")
        month_sectionFB._addedBlocks = setCriteria(pLast, month_sectionFB.parameters, param,
            SqlSyntax.GreaterThan, month_sectionFB._addedBlocks);
      else
        month_sectionFB._addedBlocks = setCriteria(pLast, month_sectionFB.parameters, param,
            SqlSyntax.LessThanOrEquals, month_sectionFB._addedBlocks);
    }
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    month_sectionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, month_sectionFB.parameters, param,
        SqlSyntax.GreaterThan, month_sectionFB._addedBlocks)
        : setCriteria(pValue, month_sectionFB.parameters, param,
        SqlSyntax.LessThanOrEquals, month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    month_sectionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, month_sectionFB.parameters, param, SqlSyntax.LessThan,
        month_sectionFB._addedBlocks)
        : setCriteria(pValue, month_sectionFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    month_sectionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, month_sectionFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, month_sectionFB._addedBlocks)
        : setCriteria(pValue, month_sectionFB.parameters, param, SqlSyntax.LessThan,
        month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    month_sectionFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, month_sectionFB.parameters, param,
        SqlSyntax.LessThanOrEquals, month_sectionFB._addedBlocks)
        : setCriteria(pValue, month_sectionFB.parameters, param,
        SqlSyntax.GreaterThan, month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
  Month_sectionFilterBuilder inValues(var pValue) {
    month_sectionFB._addedBlocks = setCriteria(
        pValue,
        month_sectionFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        month_sectionFB._addedBlocks);
    _waitingNot = "";
    month_sectionFB._addedBlocks.needEndBlock[month_sectionFB._blockIndex] =
        month_sectionFB._addedBlocks.retVal;
    return month_sectionFB;
  }
}
// endregion Month_sectionField

// region Month_sectionFilterBuilder
class Month_sectionFilterBuilder extends SearchCriteria {
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Month_section _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;
  Month_sectionFilterBuilder(Month_section obj) {
    whereString = "";
    qparams = new QueryParams();
    parameters = List<DbParameter>();
    orderByList = List<String>();
    groupByList = List<String>();
    _addedBlocks = new AddedBlocks(new List<bool>(), new List<bool>());
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }

  Month_sectionFilterBuilder get and {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " AND ";
    return this;
  }

  Month_sectionFilterBuilder get or {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " OR ";
    return this;
  }

  Month_sectionFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  Month_sectionFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != "") {
      DbParameter param = new DbParameter();
      _addedBlocks = setCriteria(
          0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  Month_sectionFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  Month_sectionFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  Month_sectionFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += " ) ";
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  Month_sectionFilterBuilder orderBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add(argFields);
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s ");
        }
    }
    return this;
  }

  Month_sectionFilterBuilder orderByDesc(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add("$argFields desc ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s desc ");
        }
    }
    return this;
  }

  Month_sectionFilterBuilder groupBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.groupByList.add(" $argFields ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.groupByList.add(" $s ");
        }
    }
    return this;
  }

  Month_sectionField setField(Month_sectionField field, String colName, DbType dbtype) {
    field = new Month_sectionField(this);
    field.param = new DbParameter(
        dbType: dbtype,
        columnName: colName,
        wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
    return field;
  }

  Month_sectionField _id;
  Month_sectionField get id {
    _id = setField(_id, "id", DbType.integer);
    return _id;
  }
  Month_sectionField _month_title;
  Month_sectionField get month_title {
    _month_title = setField(_month_title, "month_title", DbType.text);
    return _month_title;
  }
  Month_sectionField _month_description;
  Month_sectionField get month_description {
    _month_description = setField(_month_description, "month_description", DbType.text);
    return _month_description;
  }
  Month_sectionField _price;
  Month_sectionField get price {
    _price = setField(_price, "price", DbType.text);
    return _price;
  }
  Month_sectionField _key;
  Month_sectionField get key {
    _key = setField(_key, "key", DbType.text);
    return _key;
  }


  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams.limit = _pagesize;
      qparams.offset = (_page - 1) * _pagesize;
    } else {
      qparams.limit = _pagesize;
      qparams.offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll("[", "")
              .replaceAll("]", "")
              .toString();
          whereString += param.whereString
              .replaceAll("{field}", param.columnName)
              .replaceAll("?", param.value);
          param.value = null;
        } else
          whereString +=
              param.whereString.replaceAll("{field}", param.columnName);
        switch (param.dbType) {
          case DbType.bool:
            if (param.value != null) param.value = param.value ? 1 : 0;
            break;
          default:
        }

        if (param.value != null) whereArguments.add(param.value);
        if (param.value2 != null) whereArguments.add(param.value2);
      } else
        whereString += param.whereString;
    }
    if (Month_section._softDeleteActivated) {
      if (whereString != "")
        whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
            " ($whereString)";
      else if (!_getIsDeleted) whereString = "ifnull(isDeleted,0)=0";
    }

    if (whereString != "") qparams.whereString = whereString;
    qparams.whereArguments = whereArguments;
    qparams.groupBy = groupByList.join(',');
    qparams.orderBy = orderByList.join(',');
  }


  /// <summary>
  /// Deletes List<Month_section> batch by query
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    _buildParameters();
    var r= BoolResult();
    if(Month_section._softDeleteActivated)
      r = await _obj._mnMonth_section.updateBatch(qparams,{"isDeleted":1});
    else
      r = await _obj._mnMonth_section.delete(qparams);
    return r;
  }


  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    return _obj._mnMonth_section.updateBatch(qparams, values);
  }

  /// This method always returns Month_sectionObj if exist, otherwise returns null
  /// <returns>List<Month_section></returns>
  void toSingle(VoidCallback month_section(Month_section o)) {
    _pagesize = 1;
    _buildParameters();
    var objFuture = _obj._mnMonth_section.toList(qparams);
    objFuture.then((data) {
      if (data.length > 0)
        month_section(Month_section.fromMap(data[0]));
      else
        month_section(null);
    });
  }


  /// This method always returns int.
  /// <returns>int</returns>
  Future<BoolResult> toCount(VoidCallback month_sectionCount (int c)) async {
    _buildParameters();
    qparams.selectColumns = ["COUNT(1) AS CNT"];
    var month_sectionsFuture = await _obj._mnMonth_section.toList(qparams);
    int count = month_sectionsFuture[0]["CNT"];
    month_sectionCount (count);
    return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
  }

  /// This method always returns List<Month_section>.
  /// <returns>List<Month_section></returns>
  void toList(VoidCallback month_sectionList (List<Month_section> o)) async {

    _buildParameters();

    var month_sectionsFuture = _obj._mnMonth_section.toList(qparams);

    List<Month_section> month_sectionsData = new List<Month_section>();
    month_sectionsFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        month_sectionsData.add(Month_section.fromMap(data[i]));
      }
      month_sectionList (month_sectionsData);
      month_sectionsData = null;
    });
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int></returns>
  Future<List<int>> toListPrimaryKey(VoidCallback idList (List<int> o),
      [bool buildParameters=true]) async {
    if(buildParameters) _buildParameters();
    List<int> idData = new List<int>();
    qparams.selectColumns= ["id"];
    var idFuture = await _obj._mnMonth_section.toList(qparams);

    int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]["id"]);
    }
    idList (idData);
    return idData;
  }

  void toListObject(VoidCallback listObject(List<dynamic> o)) async {
    _buildParameters();

    var objectFuture = _obj._mnMonth_section.toList(qparams);

    List<dynamic> objectsData = new List<dynamic>();
    objectFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        objectsData.add(data[i]);
      }
      listObject(objectsData);
      objectsData = null;
    });


  }

}
// endregion Month_sectionFilterBuilder




// region Month_sectionFields
class Month_sectionFields {
  static TableField _fId;
  static TableField get id {
    _fId = SqlSyntax.setField(_fId, "id", DbType.integer);
    return _fId;
  }
  static TableField _fMonth_title;
  static TableField get month_title {
    _fMonth_title = SqlSyntax.setField(_fMonth_title, "month_title", DbType.text);
    return _fMonth_title;
  }
  static TableField _fMonth_description;
  static TableField get month_description {
    _fMonth_description = SqlSyntax.setField(_fMonth_description, "month_description", DbType.text);
    return _fMonth_description;
  }
  static TableField _fPrice;
  static TableField get price {
    _fPrice = SqlSyntax.setField(_fPrice, "price", DbType.text);
    return _fPrice;
  }
  static TableField _fKey;
  static TableField get key {
    _fKey = SqlSyntax.setField(_fKey, "key", DbType.text);
    return _fKey;
  }

}
// endregion Month_sectionFields

//region Month_sectionManager
class Month_sectionManager extends SqfEntityProvider {
  static String _tableName = "month_section";
  static String _colId = "id";
  Month_sectionManager():super(AppDatabase(),tableName: _tableName, colId: _colId);
}
//endregion Month_sectionManager


/*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following:
      - import Month.dart into where to use
      - start typing Month().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(month) / or toList(monthList)
      - you can select one Month or List<Month> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
// region Month
class Month {
  // FIELDS
  int id;
  String resnumber;
  String invoice_id;
  String payment;
  String month_key;
  // end FIELDS


  static const bool _softDeleteActivated=false;
  MonthManager __mnMonth;
  MonthFilterBuilder _select;

  MonthManager get _mnMonth {
    if (__mnMonth == null) __mnMonth = new MonthManager();
    return __mnMonth;
  }

  Month({this.id, this.resnumber,this.invoice_id,this.payment,this.month_key}) { setDefaultValues();}
  Month.withFields(this.resnumber,this.invoice_id,this.payment,this.month_key){ setDefaultValues();}
  Month.withId(this.id, this.resnumber,this.invoice_id,this.payment,this.month_key){ setDefaultValues();}

  // methods
  Map<String, dynamic> toMap({bool forQuery=false}) {
    var map = Map<String, dynamic>();
    if (id != null) map["id"] = id;    if (resnumber != null) map["resnumber"] = resnumber;
    if (invoice_id != null) map["invoice_id"] = invoice_id;
    if (payment != null) map["payment"] = payment;
    if (month_key != null) map["month_key"] = month_key;

    return map;
  }

  Month.fromMap(Map<String, dynamic> o) {
    this.id = o["id"];
    this.resnumber = o["resnumber"];
    this.invoice_id = o["invoice_id"];
    this.payment = o["payment"];
    this.month_key = o["month_key"];

  }

  List<dynamic> toArgs() {
    return[id,resnumber,invoice_id,payment,month_key];
  }


  static fromWebUrl(String url, VoidCallback  monthList (List<Month> o)) async {
    var objList = List<Month>();
    http.get(url).then((response) {
      Iterable list = json.decode(response.body);
      try {
        objList = list.map((month) => Month.fromMap(month)).toList();
        monthList(objList); return;
      } catch (e) {
        print("SQFENTITY ERROR Month.fromWeb: ErrorMessage:" + e.toString());
      }
    });
  }

  static Future<List<Month>> fromObjectList(Future<List<dynamic>> o) async {
    var monthsList = new List<Month>();
    o.then((data) {
      for (int i = 0; i < data.length; i++) {
        monthsList.add(Month.fromMap(data[i]));
      }
    });
    return monthsList;
  }

  static List<Month> fromMapList(List<Map<String, dynamic>> query) {
    List<Month> months = List<Month>();
    for (Map map in query) {
      months.add(Month.fromMap(map));
    }
    return months;
  }

  /// returns Month by ID if exist, otherwise returns null
  /// <param name="id">Primary Key Value</param>
  /// <returns>returns Month if exist, otherwise returns null</returns>
  getById(int id, VoidCallback month(Month o)) {
    Month monthObj;
    var monthFuture = _mnMonth.getById(id);
    monthFuture.then((data) {
      if (data.length > 0)
        monthObj = Month.fromMap(data[0]);
      else
        monthObj = null;
      month(monthObj);
    });
  }

  /// <summary>
  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> save() async {
    if (id == null || id == 0)
      id = await _mnMonth.insert(
          Month.withFields(resnumber,invoice_id,payment,month_key));
    else
      id= await _upsert();
    return id;
  }

  /// <summary>
  /// saveAll method saves the sent List<Month> as a batch in one transaction
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> saveAll(List<Month> months) async {
    var results = _mnMonth.saveAll("INSERT OR REPLACE INTO month (id, resnumber,invoice_id,payment,month_key)  VALUES (?,?,?,?,?)",months);
    return results;
  }

  /// <summary>
  /// Updates if the record exists, otherwise adds a new row
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> _upsert() async {
    id = await _mnMonth.rawInsert(
        "INSERT OR REPLACE INTO month (id, resnumber,invoice_id,payment,month_key)  VALUES (?,?,?,?,?)", [id,resnumber,invoice_id,payment,month_key]);
    return id;
  }


  /// <summary>
  /// inserts or replaces the sent List<Todo> as a batch in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> upsertAll(List<Month> months) async {
    var results = await _mnMonth.rawInsertAll(
        "INSERT OR REPLACE INTO month (id, resnumber,invoice_id,payment,month_key)  VALUES (?,?,?,?,?)", months);
    return results;
  }


  /// <summary>
  /// saveAs Month. Returns a new Primary Key value of Month
  /// </summary>
  /// <returns>Returns a new Primary Key value of Month</returns>
  Future<int> saveAs() async {
    id = await _mnMonth.insert(
        Month.withFields(resnumber,invoice_id,payment,month_key));
    return id;
  }


  /// <summary>
  /// Deletes Month
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    print("SQFENTITIY: delete Month invoked (id=$id)");
    if (!_softDeleteActivated)
      return _mnMonth.delete(QueryParams(whereString: "id=$id"));
    else
      return _mnMonth.updateBatch(QueryParams(whereString: "id=$id"), {"isDeleted": 1});
  }

  //private MonthFilterBuilder _Select;
  MonthFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    _select = new MonthFilterBuilder(this);
    _select._getIsDeleted = getIsDeleted==true;
    _select.qparams.selectColumns = columnsToSelect;
    return _select;
  }

  MonthFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    MonthFilterBuilder _distinct = new MonthFilterBuilder(this);
    _distinct._getIsDeleted = getIsDeleted==true;
    _distinct.qparams.selectColumns = columnsToSelect;
    _distinct.qparams.distinct = true;
    return _distinct;
  }

  void setDefaultValues() {

  }
//end methods
}
// endregion month


// region MonthField
class MonthField extends SearchCriteria {
  DbParameter param;
  String _waitingNot = "";
  MonthFilterBuilder monthFB;
  MonthField(MonthFilterBuilder fb) {
    param = new DbParameter();
    monthFB = fb;
  }
  MonthField get not {
    _waitingNot = " NOT ";
    return this;
  }
  MonthFilterBuilder equals(var pValue) {
    param.expression = "=";
    monthFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, monthFB.parameters, param, SqlSyntax.EQuals,
        monthFB._addedBlocks)
        : setCriteria(pValue, monthFB.parameters, param, SqlSyntax.NotEQuals,
        monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder isNull() {
    monthFB._addedBlocks = setCriteria(
        0,
        monthFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder contains(dynamic pValue) {
    monthFB._addedBlocks = setCriteria(
        "%" + pValue + "%",
        monthFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder startsWith(dynamic pValue) {
    monthFB._addedBlocks = setCriteria(
        pValue + "%",
        monthFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder endsWith(dynamic pValue) {
    monthFB._addedBlocks = setCriteria(
        "%" + pValue,
        monthFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      monthFB._addedBlocks = setCriteria(
          pFirst,
          monthFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          monthFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "")
        monthFB._addedBlocks = setCriteria(pFirst, monthFB.parameters,
            param, SqlSyntax.LessThan, monthFB._addedBlocks);
      else
        monthFB._addedBlocks = setCriteria(pFirst, monthFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, monthFB._addedBlocks);
    } else if (pLast != null) {
      if (_waitingNot != "")
        monthFB._addedBlocks = setCriteria(pLast, monthFB.parameters, param,
            SqlSyntax.GreaterThan, monthFB._addedBlocks);
      else
        monthFB._addedBlocks = setCriteria(pLast, monthFB.parameters, param,
            SqlSyntax.LessThanOrEquals, monthFB._addedBlocks);
    }
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    monthFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, monthFB.parameters, param,
        SqlSyntax.GreaterThan, monthFB._addedBlocks)
        : setCriteria(pValue, monthFB.parameters, param,
        SqlSyntax.LessThanOrEquals, monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    monthFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, monthFB.parameters, param, SqlSyntax.LessThan,
        monthFB._addedBlocks)
        : setCriteria(pValue, monthFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    monthFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, monthFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, monthFB._addedBlocks)
        : setCriteria(pValue, monthFB.parameters, param, SqlSyntax.LessThan,
        monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    monthFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, monthFB.parameters, param,
        SqlSyntax.LessThanOrEquals, monthFB._addedBlocks)
        : setCriteria(pValue, monthFB.parameters, param,
        SqlSyntax.GreaterThan, monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
  MonthFilterBuilder inValues(var pValue) {
    monthFB._addedBlocks = setCriteria(
        pValue,
        monthFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        monthFB._addedBlocks);
    _waitingNot = "";
    monthFB._addedBlocks.needEndBlock[monthFB._blockIndex] =
        monthFB._addedBlocks.retVal;
    return monthFB;
  }
}
// endregion MonthField

// region MonthFilterBuilder
class MonthFilterBuilder extends SearchCriteria {
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Month _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;
  MonthFilterBuilder(Month obj) {
    whereString = "";
    qparams = new QueryParams();
    parameters = List<DbParameter>();
    orderByList = List<String>();
    groupByList = List<String>();
    _addedBlocks = new AddedBlocks(new List<bool>(), new List<bool>());
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }

  MonthFilterBuilder get and {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " AND ";
    return this;
  }

  MonthFilterBuilder get or {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " OR ";
    return this;
  }

  MonthFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  MonthFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != "") {
      DbParameter param = new DbParameter();
      _addedBlocks = setCriteria(
          0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  MonthFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  MonthFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  MonthFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += " ) ";
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  MonthFilterBuilder orderBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add(argFields);
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s ");
        }
    }
    return this;
  }

  MonthFilterBuilder orderByDesc(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add("$argFields desc ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s desc ");
        }
    }
    return this;
  }

  MonthFilterBuilder groupBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.groupByList.add(" $argFields ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.groupByList.add(" $s ");
        }
    }
    return this;
  }

  MonthField setField(MonthField field, String colName, DbType dbtype) {
    field = new MonthField(this);
    field.param = new DbParameter(
        dbType: dbtype,
        columnName: colName,
        wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
    return field;
  }

  MonthField _id;
  MonthField get id {
    _id = setField(_id, "id", DbType.integer);
    return _id;
  }
  MonthField _resnumber;
  MonthField get resnumber {
    _resnumber = setField(_resnumber, "resnumber", DbType.text);
    return _resnumber;
  }
  MonthField _invoice_id;
  MonthField get invoice_id {
    _invoice_id = setField(_invoice_id, "invoice_id", DbType.text);
    return _invoice_id;
  }
  MonthField _payment;
  MonthField get payment {
    _payment = setField(_payment, "payment", DbType.text);
    return _payment;
  }
  MonthField _month_key;
  MonthField get month_key {
    _month_key = setField(_month_key, "month_key", DbType.text);
    return _month_key;
  }


  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams.limit = _pagesize;
      qparams.offset = (_page - 1) * _pagesize;
    } else {
      qparams.limit = _pagesize;
      qparams.offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll("[", "")
              .replaceAll("]", "")
              .toString();
          whereString += param.whereString
              .replaceAll("{field}", param.columnName)
              .replaceAll("?", param.value);
          param.value = null;
        } else
          whereString +=
              param.whereString.replaceAll("{field}", param.columnName);
        switch (param.dbType) {
          case DbType.bool:
            if (param.value != null) param.value = param.value ? 1 : 0;
            break;
          default:
        }

        if (param.value != null) whereArguments.add(param.value);
        if (param.value2 != null) whereArguments.add(param.value2);
      } else
        whereString += param.whereString;
    }
    if (Month._softDeleteActivated) {
      if (whereString != "")
        whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
            " ($whereString)";
      else if (!_getIsDeleted) whereString = "ifnull(isDeleted,0)=0";
    }

    if (whereString != "") qparams.whereString = whereString;
    qparams.whereArguments = whereArguments;
    qparams.groupBy = groupByList.join(',');
    qparams.orderBy = orderByList.join(',');
  }


  /// <summary>
  /// Deletes List<Month> batch by query
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    _buildParameters();
    var r= BoolResult();
    if(Month._softDeleteActivated)
      r = await _obj._mnMonth.updateBatch(qparams,{"isDeleted":1});
    else
      r = await _obj._mnMonth.delete(qparams);
    return r;
  }


  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    return _obj._mnMonth.updateBatch(qparams, values);
  }

  /// This method always returns MonthObj if exist, otherwise returns null
  /// <returns>List<Month></returns>
  void toSingle(VoidCallback month(Month o)) {
    _pagesize = 1;
    _buildParameters();
    var objFuture = _obj._mnMonth.toList(qparams);
    objFuture.then((data) {
      if (data.length > 0)
        month(Month.fromMap(data[0]));
      else
        month(null);
    });
  }


  /// This method always returns int.
  /// <returns>int</returns>
  Future<BoolResult> toCount(VoidCallback monthCount (int c)) async {
    _buildParameters();
    qparams.selectColumns = ["COUNT(1) AS CNT"];
    var monthsFuture = await _obj._mnMonth.toList(qparams);
    int count = monthsFuture[0]["CNT"];
    monthCount (count);
    return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
  }

  /// This method always returns List<Month>.
  /// <returns>List<Month></returns>
  void toList(VoidCallback monthList (List<Month> o)) async {

    _buildParameters();

    var monthsFuture = _obj._mnMonth.toList(qparams);

    List<Month> monthsData = new List<Month>();
    monthsFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        monthsData.add(Month.fromMap(data[i]));
      }
      monthList (monthsData);
      monthsData = null;
    });
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int></returns>
  Future<List<int>> toListPrimaryKey(VoidCallback idList (List<int> o),
      [bool buildParameters=true]) async {
    if(buildParameters) _buildParameters();
    List<int> idData = new List<int>();
    qparams.selectColumns= ["id"];
    var idFuture = await _obj._mnMonth.toList(qparams);

    int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]["id"]);
    }
    idList (idData);
    return idData;
  }

  void toListObject(VoidCallback listObject(List<dynamic> o)) async {
    _buildParameters();

    var objectFuture = _obj._mnMonth.toList(qparams);

    List<dynamic> objectsData = new List<dynamic>();
    objectFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        objectsData.add(data[i]);
      }
      listObject(objectsData);
      objectsData = null;
    });


  }

}
// endregion MonthFilterBuilder




// region MonthFields
class MonthFields {
  static TableField _fId;
  static TableField get id {
    _fId = SqlSyntax.setField(_fId, "id", DbType.integer);
    return _fId;
  }
  static TableField _fResnumber;
  static TableField get resnumber {
    _fResnumber = SqlSyntax.setField(_fResnumber, "resnumber", DbType.text);
    return _fResnumber;
  }
  static TableField _fInvoice_id;
  static TableField get invoice_id {
    _fInvoice_id = SqlSyntax.setField(_fInvoice_id, "invoice_id", DbType.text);
    return _fInvoice_id;
  }
  static TableField _fPayment;
  static TableField get payment {
    _fPayment = SqlSyntax.setField(_fPayment, "payment", DbType.text);
    return _fPayment;
  }
  static TableField _fMonth_key;
  static TableField get month_key {
    _fMonth_key = SqlSyntax.setField(_fMonth_key, "month_key", DbType.text);
    return _fMonth_key;
  }

}
// endregion MonthFields

//region MonthManager
class MonthManager extends SqfEntityProvider {
  static String _tableName = "month";
  static String _colId = "id";
  MonthManager():super(AppDatabase(),tableName: _tableName, colId: _colId);
}
//endregion MonthManager


/*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following:
      - import Payment.dart into where to use
      - start typing Payment().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(payment) / or toList(paymentList)
      - you can select one Payment or List<Payment> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
// region Payment
class Payment {
  // FIELDS
  int id;
  String title;
  String category;
  String image;
  // end FIELDS


  static const bool _softDeleteActivated=false;
  PaymentManager __mnPayment;
  PaymentFilterBuilder _select;

  PaymentManager get _mnPayment {
    if (__mnPayment == null) __mnPayment = new PaymentManager();
    return __mnPayment;
  }

  Payment({this.id, this.title,this.category,this.image}) { setDefaultValues();}
  Payment.withFields(this.title,this.category,this.image){ setDefaultValues();}
  Payment.withId(this.id, this.title,this.category,this.image){ setDefaultValues();}

  // methods
  Map<String, dynamic> toMap({bool forQuery=false}) {
    var map = Map<String, dynamic>();
    if (id != null) map["id"] = id;    if (title != null) map["title"] = title;
    if (category != null) map["category"] = category;
    if (image != null) map["image"] = image;

    return map;
  }

  Payment.fromMap(Map<String, dynamic> o) {
    this.id = o["id"];
    this.title = o["title"];
    this.category = o["category"];
    this.image = o["image"];

  }

  List<dynamic> toArgs() {
    return[id,title,category,image];
  }


  static fromWebUrl(String url, VoidCallback  paymentList (List<Payment> o)) async {
    var objList = List<Payment>();
    http.get(url).then((response) {
      Iterable list = json.decode(response.body);
      try {
        objList = list.map((payment) => Payment.fromMap(payment)).toList();
        paymentList(objList); return;
      } catch (e) {
        print("SQFENTITY ERROR Payment.fromWeb: ErrorMessage:" + e.toString());
      }
    });
  }

  static Future<List<Payment>> fromObjectList(Future<List<dynamic>> o) async {
    var paymentsList = new List<Payment>();
    o.then((data) {
      for (int i = 0; i < data.length; i++) {
        paymentsList.add(Payment.fromMap(data[i]));
      }
    });
    return paymentsList;
  }

  static List<Payment> fromMapList(List<Map<String, dynamic>> query) {
    List<Payment> payments = List<Payment>();
    for (Map map in query) {
      payments.add(Payment.fromMap(map));
    }
    return payments;
  }

  /// returns Payment by ID if exist, otherwise returns null
  /// <param name="id">Primary Key Value</param>
  /// <returns>returns Payment if exist, otherwise returns null</returns>
  getById(int id, VoidCallback payment(Payment o)) {
    Payment paymentObj;
    var paymentFuture = _mnPayment.getById(id);
    paymentFuture.then((data) {
      if (data.length > 0)
        paymentObj = Payment.fromMap(data[0]);
      else
        paymentObj = null;
      payment(paymentObj);
    });
  }

  /// <summary>
  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> save() async {
    if (id == null || id == 0)
      id = await _mnPayment.insert(
          Payment.withFields(title,category,image));
    else
      id= await _upsert();
    return id;
  }

  /// <summary>
  /// saveAll method saves the sent List<Payment> as a batch in one transaction
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> saveAll(List<Payment> payments) async {
    var results = _mnPayment.saveAll("INSERT OR REPLACE INTO payments (id, title,category,image)  VALUES (?,?,?,?)",payments);
    return results;
  }

  /// <summary>
  /// Updates if the record exists, otherwise adds a new row
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> _upsert() async {
    id = await _mnPayment.rawInsert(
        "INSERT OR REPLACE INTO payments (id, title,category,image)  VALUES (?,?,?,?)", [id,title,category,image]);
    return id;
  }


  /// <summary>
  /// inserts or replaces the sent List<Todo> as a batch in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> upsertAll(List<Payment> payments) async {
    var results = await _mnPayment.rawInsertAll(
        "INSERT OR REPLACE INTO payments (id, title,category,image)  VALUES (?,?,?,?)", payments);
    return results;
  }


  /// <summary>
  /// saveAs Payment. Returns a new Primary Key value of Payment
  /// </summary>
  /// <returns>Returns a new Primary Key value of Payment</returns>
  Future<int> saveAs() async {
    id = await _mnPayment.insert(
        Payment.withFields(title,category,image));
    return id;
  }


  /// <summary>
  /// Deletes Payment
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    print("SQFENTITIY: delete Payment invoked (id=$id)");
    if (!_softDeleteActivated)
      return _mnPayment.delete(QueryParams(whereString: "id=$id"));
    else
      return _mnPayment.updateBatch(QueryParams(whereString: "id=$id"), {"isDeleted": 1});
  }

  //private PaymentFilterBuilder _Select;
  PaymentFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    _select = new PaymentFilterBuilder(this);
    _select._getIsDeleted = getIsDeleted==true;
    _select.qparams.selectColumns = columnsToSelect;
    return _select;
  }

  PaymentFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    PaymentFilterBuilder _distinct = new PaymentFilterBuilder(this);
    _distinct._getIsDeleted = getIsDeleted==true;
    _distinct.qparams.selectColumns = columnsToSelect;
    _distinct.qparams.distinct = true;
    return _distinct;
  }

  void setDefaultValues() {

  }
//end methods
}
// endregion payment


// region PaymentField
class PaymentField extends SearchCriteria {
  DbParameter param;
  String _waitingNot = "";
  PaymentFilterBuilder paymentFB;
  PaymentField(PaymentFilterBuilder fb) {
    param = new DbParameter();
    paymentFB = fb;
  }
  PaymentField get not {
    _waitingNot = " NOT ";
    return this;
  }
  PaymentFilterBuilder equals(var pValue) {
    param.expression = "=";
    paymentFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, paymentFB.parameters, param, SqlSyntax.EQuals,
        paymentFB._addedBlocks)
        : setCriteria(pValue, paymentFB.parameters, param, SqlSyntax.NotEQuals,
        paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder isNull() {
    paymentFB._addedBlocks = setCriteria(
        0,
        paymentFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder contains(dynamic pValue) {
    paymentFB._addedBlocks = setCriteria(
        "%" + pValue + "%",
        paymentFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder startsWith(dynamic pValue) {
    paymentFB._addedBlocks = setCriteria(
        pValue + "%",
        paymentFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder endsWith(dynamic pValue) {
    paymentFB._addedBlocks = setCriteria(
        "%" + pValue,
        paymentFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      paymentFB._addedBlocks = setCriteria(
          pFirst,
          paymentFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          paymentFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "")
        paymentFB._addedBlocks = setCriteria(pFirst, paymentFB.parameters,
            param, SqlSyntax.LessThan, paymentFB._addedBlocks);
      else
        paymentFB._addedBlocks = setCriteria(pFirst, paymentFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, paymentFB._addedBlocks);
    } else if (pLast != null) {
      if (_waitingNot != "")
        paymentFB._addedBlocks = setCriteria(pLast, paymentFB.parameters, param,
            SqlSyntax.GreaterThan, paymentFB._addedBlocks);
      else
        paymentFB._addedBlocks = setCriteria(pLast, paymentFB.parameters, param,
            SqlSyntax.LessThanOrEquals, paymentFB._addedBlocks);
    }
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    paymentFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, paymentFB.parameters, param,
        SqlSyntax.GreaterThan, paymentFB._addedBlocks)
        : setCriteria(pValue, paymentFB.parameters, param,
        SqlSyntax.LessThanOrEquals, paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    paymentFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, paymentFB.parameters, param, SqlSyntax.LessThan,
        paymentFB._addedBlocks)
        : setCriteria(pValue, paymentFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    paymentFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, paymentFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, paymentFB._addedBlocks)
        : setCriteria(pValue, paymentFB.parameters, param, SqlSyntax.LessThan,
        paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    paymentFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, paymentFB.parameters, param,
        SqlSyntax.LessThanOrEquals, paymentFB._addedBlocks)
        : setCriteria(pValue, paymentFB.parameters, param,
        SqlSyntax.GreaterThan, paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
  PaymentFilterBuilder inValues(var pValue) {
    paymentFB._addedBlocks = setCriteria(
        pValue,
        paymentFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        paymentFB._addedBlocks);
    _waitingNot = "";
    paymentFB._addedBlocks.needEndBlock[paymentFB._blockIndex] =
        paymentFB._addedBlocks.retVal;
    return paymentFB;
  }
}
// endregion PaymentField

// region PaymentFilterBuilder
class PaymentFilterBuilder extends SearchCriteria {
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  Payment _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;
  PaymentFilterBuilder(Payment obj) {
    whereString = "";
    qparams = new QueryParams();
    parameters = List<DbParameter>();
    orderByList = List<String>();
    groupByList = List<String>();
    _addedBlocks = new AddedBlocks(new List<bool>(), new List<bool>());
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }

  PaymentFilterBuilder get and {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " AND ";
    return this;
  }

  PaymentFilterBuilder get or {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " OR ";
    return this;
  }

  PaymentFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  PaymentFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != "") {
      DbParameter param = new DbParameter();
      _addedBlocks = setCriteria(
          0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  PaymentFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  PaymentFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  PaymentFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += " ) ";
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  PaymentFilterBuilder orderBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add(argFields);
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s ");
        }
    }
    return this;
  }

  PaymentFilterBuilder orderByDesc(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add("$argFields desc ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s desc ");
        }
    }
    return this;
  }

  PaymentFilterBuilder groupBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.groupByList.add(" $argFields ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.groupByList.add(" $s ");
        }
    }
    return this;
  }

  PaymentField setField(PaymentField field, String colName, DbType dbtype) {
    field = new PaymentField(this);
    field.param = new DbParameter(
        dbType: dbtype,
        columnName: colName,
        wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
    return field;
  }

  PaymentField _id;
  PaymentField get id {
    _id = setField(_id, "id", DbType.integer);
    return _id;
  }
  PaymentField _title;
  PaymentField get title {
    _title = setField(_title, "title", DbType.text);
    return _title;
  }
  PaymentField _category;
  PaymentField get category {
    _category = setField(_category, "category", DbType.text);
    return _category;
  }
  PaymentField _image;
  PaymentField get image {
    _image = setField(_image, "image", DbType.text);
    return _image;
  }


  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams.limit = _pagesize;
      qparams.offset = (_page - 1) * _pagesize;
    } else {
      qparams.limit = _pagesize;
      qparams.offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll("[", "")
              .replaceAll("]", "")
              .toString();
          whereString += param.whereString
              .replaceAll("{field}", param.columnName)
              .replaceAll("?", param.value);
          param.value = null;
        } else
          whereString +=
              param.whereString.replaceAll("{field}", param.columnName);
        switch (param.dbType) {
          case DbType.bool:
            if (param.value != null) param.value = param.value ? 1 : 0;
            break;
          default:
        }

        if (param.value != null) whereArguments.add(param.value);
        if (param.value2 != null) whereArguments.add(param.value2);
      } else
        whereString += param.whereString;
    }
    if (Payment._softDeleteActivated) {
      if (whereString != "")
        whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
            " ($whereString)";
      else if (!_getIsDeleted) whereString = "ifnull(isDeleted,0)=0";
    }

    if (whereString != "") qparams.whereString = whereString;
    qparams.whereArguments = whereArguments;
    qparams.groupBy = groupByList.join(',');
    qparams.orderBy = orderByList.join(',');
  }


  /// <summary>
  /// Deletes List<Payment> batch by query
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    _buildParameters();
    var r= BoolResult();
    if(Payment._softDeleteActivated)
      r = await _obj._mnPayment.updateBatch(qparams,{"isDeleted":1});
    else
      r = await _obj._mnPayment.delete(qparams);
    return r;
  }


  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    return _obj._mnPayment.updateBatch(qparams, values);
  }

  /// This method always returns PaymentObj if exist, otherwise returns null
  /// <returns>List<Payment></returns>
  void toSingle(VoidCallback payment(Payment o)) {
    _pagesize = 1;
    _buildParameters();
    var objFuture = _obj._mnPayment.toList(qparams);
    objFuture.then((data) {
      if (data.length > 0)
        payment(Payment.fromMap(data[0]));
      else
        payment(null);
    });
  }


  /// This method always returns int.
  /// <returns>int</returns>
  Future<BoolResult> toCount(VoidCallback paymentCount (int c)) async {
    _buildParameters();
    qparams.selectColumns = ["COUNT(1) AS CNT"];
    var paymentsFuture = await _obj._mnPayment.toList(qparams);
    int count = paymentsFuture[0]["CNT"];
    paymentCount (count);
    return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
  }

  /// This method always returns List<Payment>.
  /// <returns>List<Payment></returns>
  void toList(VoidCallback paymentList (List<Payment> o)) async {

    _buildParameters();

    var paymentsFuture = _obj._mnPayment.toList(qparams);

    List<Payment> paymentsData = new List<Payment>();
    paymentsFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        paymentsData.add(Payment.fromMap(data[i]));
      }
      paymentList (paymentsData);
      paymentsData = null;
    });
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int></returns>
  Future<List<int>> toListPrimaryKey(VoidCallback idList (List<int> o),
      [bool buildParameters=true]) async {
    if(buildParameters) _buildParameters();
    List<int> idData = new List<int>();
    qparams.selectColumns= ["id"];
    var idFuture = await _obj._mnPayment.toList(qparams);

    int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]["id"]);
    }
    idList (idData);
    return idData;
  }

  void toListObject(VoidCallback listObject(List<dynamic> o)) async {
    _buildParameters();

    var objectFuture = _obj._mnPayment.toList(qparams);

    List<dynamic> objectsData = new List<dynamic>();
    objectFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        objectsData.add(data[i]);
      }
      listObject(objectsData);
      objectsData = null;
    });


  }

}
// endregion PaymentFilterBuilder




// region PaymentFields
class PaymentFields {
  static TableField _fId;
  static TableField get id {
    _fId = SqlSyntax.setField(_fId, "id", DbType.integer);
    return _fId;
  }
  static TableField _fTitle;
  static TableField get title {
    _fTitle = SqlSyntax.setField(_fTitle, "title", DbType.text);
    return _fTitle;
  }
  static TableField _fCategory;
  static TableField get category {
    _fCategory = SqlSyntax.setField(_fCategory, "category", DbType.text);
    return _fCategory;
  }
  static TableField _fImage;
  static TableField get image {
    _fImage = SqlSyntax.setField(_fImage, "image", DbType.text);
    return _fImage;
  }

}
// endregion PaymentFields

//region PaymentManager
class PaymentManager extends SqfEntityProvider {
  static String _tableName = "payments";
  static String _colId = "id";
  PaymentManager():super(AppDatabase(),tableName: _tableName, colId: _colId);
}
//endregion PaymentManager


/*
      These classes was generated by SqfEntity
      To use these SqfEntity classes do following:
      - import User.dart into where to use
      - start typing User().select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
      - and then just put end of filters / or end of only select()  toSingle(user) / or toList(userList)
      - you can select one User or List<User> by your filters and orders
      - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
        Enjoy.. Huseyin Tokpunar
      */
// region User
class User {
  // FIELDS
  int id;
  String password;
  bool active;
  String mobile_number;
  String api_token;
  String device_id;
  String created_at;
  String updated_at;
  // end FIELDS


  static const bool _softDeleteActivated=false;
  UserManager __mnUser;
  UserFilterBuilder _select;

  UserManager get _mnUser {
    if (__mnUser == null) __mnUser = new UserManager();
    return __mnUser;
  }

  User({this.id, this.password,this.active,this.mobile_number,this.api_token,this.device_id,this.created_at,this.updated_at}) { setDefaultValues();}
  User.withFields(this.password,this.active,this.mobile_number,this.api_token,this.device_id,this.created_at,this.updated_at){ setDefaultValues();}
  User.withId(this.id, this.password,this.active,this.mobile_number,this.api_token,this.device_id,this.created_at,this.updated_at){ setDefaultValues();}

  // methods
  Map<String, dynamic> toMap({bool forQuery=false}) {
    var map = Map<String, dynamic>();
    if (id != null) map["id"] = id;    if (password != null) map["password"] = password;
    if (active != null) map["active"] = forQuery? (active ? 1 : 0) : active;
    if (mobile_number != null) map["mobile_number"] = mobile_number;
    if (api_token != null) map["api_token"] = api_token;
    if (device_id != null) map["device_id"] = device_id;
    if (created_at != null) map["created_at"] = created_at;
    if (updated_at != null) map["updated_at"] = updated_at;

    return map;
  }

  User.fromMap(Map<String, dynamic> o) {
    this.id = o["id"];
    this.password = o["password"];
    this.active = o["active"] != null ? o["active"] == 1 : null;
    this.mobile_number = o["mobile_number"];
    this.api_token = o["api_token"];
    this.device_id = o["device_id"];
    this.created_at = o["created_at"];
    this.updated_at = o["updated_at"];

  }

  List<dynamic> toArgs() {
    return[id,password,active,mobile_number,api_token,device_id,created_at,updated_at];
  }


  static fromWebUrl(String url, VoidCallback  userList (List<User> o)) async {
    var objList = List<User>();
    http.get(url).then((response) {
      Iterable list = json.decode(response.body);
      try {
        objList = list.map((user) => User.fromMap(user)).toList();
        userList(objList); return;
      } catch (e) {
        print("SQFENTITY ERROR User.fromWeb: ErrorMessage:" + e.toString());
      }
    });
  }

  static Future<List<User>> fromObjectList(Future<List<dynamic>> o) async {
    var usersList = new List<User>();
    o.then((data) {
      for (int i = 0; i < data.length; i++) {
        usersList.add(User.fromMap(data[i]));
      }
    });
    return usersList;
  }

  static List<User> fromMapList(List<Map<String, dynamic>> query) {
    List<User> users = List<User>();
    for (Map map in query) {
      users.add(User.fromMap(map));
    }
    return users;
  }

  /// returns User by ID if exist, otherwise returns null
  /// <param name="id">Primary Key Value</param>
  /// <returns>returns User if exist, otherwise returns null</returns>
  getById(int id, VoidCallback user(User o)) {
    User userObj;
    var userFuture = _mnUser.getById(id);
    userFuture.then((data) {
      if (data.length > 0)
        userObj = User.fromMap(data[0]);
      else
        userObj = null;
      user(userObj);
    });
  }

  /// <summary>
  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> save() async {
    if (id == null || id == 0)
      id = await _mnUser.insert(
          User.withFields(password,active,mobile_number,api_token,device_id,created_at,updated_at));
    else
      id= await _upsert();
    return id;
  }

  /// <summary>
  /// saveAll method saves the sent List<User> as a batch in one transaction
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> saveAll(List<User> users) async {
    var results = _mnUser.saveAll("INSERT OR REPLACE INTO user (id, password,active,mobile_number,api_token,device_id,created_at,updated_at)  VALUES (?,?,?,?,?,?,?,?)",users);
    return results;
  }

  /// <summary>
  /// Updates if the record exists, otherwise adds a new row
  /// </summary>
  /// <returns>Returns id</returns>
  Future<int> _upsert() async {
    id = await _mnUser.rawInsert(
        "INSERT OR REPLACE INTO user (id, password,active,mobile_number,api_token,device_id,created_at,updated_at)  VALUES (?,?,?,?,?,?,?,?)", [id,password,active,mobile_number,api_token,device_id,created_at,updated_at]);
    return id;
  }


  /// <summary>
  /// inserts or replaces the sent List<Todo> as a batch in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// </summary>
  /// <returns> Returns a <List<BoolResult>> </returns>
  Future<List<BoolResult>> upsertAll(List<User> users) async {
    var results = await _mnUser.rawInsertAll(
        "INSERT OR REPLACE INTO user (id, password,active,mobile_number,api_token,device_id,created_at,updated_at)  VALUES (?,?,?,?,?,?,?,?)", users);
    return results;
  }


  /// <summary>
  /// saveAs User. Returns a new Primary Key value of User
  /// </summary>
  /// <returns>Returns a new Primary Key value of User</returns>
  Future<int> saveAs() async {
    id = await _mnUser.insert(
        User.withFields(password,active,mobile_number,api_token,device_id,created_at,updated_at));
    return id;
  }


  /// <summary>
  /// Deletes User
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    print("SQFENTITIY: delete User invoked (id=$id)");
    if (!_softDeleteActivated)
      return _mnUser.delete(QueryParams(whereString: "id=$id"));
    else
      return _mnUser.updateBatch(QueryParams(whereString: "id=$id"), {"isDeleted": 1});
  }

  //private UserFilterBuilder _Select;
  UserFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    _select = new UserFilterBuilder(this);
    _select._getIsDeleted = getIsDeleted==true;
    _select.qparams.selectColumns = columnsToSelect;
    return _select;
  }

  UserFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    UserFilterBuilder _distinct = new UserFilterBuilder(this);
    _distinct._getIsDeleted = getIsDeleted==true;
    _distinct.qparams.selectColumns = columnsToSelect;
    _distinct.qparams.distinct = true;
    return _distinct;
  }

  void setDefaultValues() {
    if(active==null) active=false;

  }
//end methods
}
// endregion user


// region UserField
class UserField extends SearchCriteria {
  DbParameter param;
  String _waitingNot = "";
  UserFilterBuilder userFB;
  UserField(UserFilterBuilder fb) {
    param = new DbParameter();
    userFB = fb;
  }
  UserField get not {
    _waitingNot = " NOT ";
    return this;
  }
  UserFilterBuilder equals(var pValue) {
    param.expression = "=";
    userFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, userFB.parameters, param, SqlSyntax.EQuals,
        userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param, SqlSyntax.NotEQuals,
        userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder isNull() {
    userFB._addedBlocks = setCriteria(
        0,
        userFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder contains(dynamic pValue) {
    userFB._addedBlocks = setCriteria(
        "%" + pValue + "%",
        userFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder startsWith(dynamic pValue) {
    userFB._addedBlocks = setCriteria(
        pValue + "%",
        userFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder endsWith(dynamic pValue) {
    userFB._addedBlocks = setCriteria(
        "%" + pValue,
        userFB.parameters,
        param,
        SqlSyntax.Contains.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      userFB._addedBlocks = setCriteria(
          pFirst,
          userFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
          userFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != "")
        userFB._addedBlocks = setCriteria(pFirst, userFB.parameters,
            param, SqlSyntax.LessThan, userFB._addedBlocks);
      else
        userFB._addedBlocks = setCriteria(pFirst, userFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, userFB._addedBlocks);
    } else if (pLast != null) {
      if (_waitingNot != "")
        userFB._addedBlocks = setCriteria(pLast, userFB.parameters, param,
            SqlSyntax.GreaterThan, userFB._addedBlocks);
      else
        userFB._addedBlocks = setCriteria(pLast, userFB.parameters, param,
            SqlSyntax.LessThanOrEquals, userFB._addedBlocks);
    }
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder greaterThan(dynamic pValue) {
    param.expression = ">";
    userFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, userFB.parameters, param,
        SqlSyntax.GreaterThan, userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param,
        SqlSyntax.LessThanOrEquals, userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder lessThan(dynamic pValue) {
    param.expression = "<";
    userFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, userFB.parameters, param, SqlSyntax.LessThan,
        userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = ">=";
    userFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, userFB.parameters, param,
        SqlSyntax.GreaterThanOrEquals, userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param, SqlSyntax.LessThan,
        userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = "<=";
    userFB._addedBlocks = _waitingNot == ""
        ? setCriteria(pValue, userFB.parameters, param,
        SqlSyntax.LessThanOrEquals, userFB._addedBlocks)
        : setCriteria(pValue, userFB.parameters, param,
        SqlSyntax.GreaterThan, userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
  UserFilterBuilder inValues(var pValue) {
    userFB._addedBlocks = setCriteria(
        pValue,
        userFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.NOT_KEYWORD, _waitingNot),
        userFB._addedBlocks);
    _waitingNot = "";
    userFB._addedBlocks.needEndBlock[userFB._blockIndex] =
        userFB._addedBlocks.retVal;
    return userFB;
  }
}
// endregion UserField

// region UserFilterBuilder
class UserFilterBuilder extends SearchCriteria {
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  User _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;
  UserFilterBuilder(User obj) {
    whereString = "";
    qparams = new QueryParams();
    parameters = List<DbParameter>();
    orderByList = List<String>();
    groupByList = List<String>();
    _addedBlocks = new AddedBlocks(new List<bool>(), new List<bool>());
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }

  UserFilterBuilder get and {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " AND ";
    return this;
  }

  UserFilterBuilder get or {
    if (parameters.length > 0)
      parameters[parameters.length - 1].wOperator = " OR ";
    return this;
  }

  UserFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  UserFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != "") {
      DbParameter param = new DbParameter();
      _addedBlocks = setCriteria(
          0, parameters, param, "(" + whereCriteria + ")", _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  UserFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  UserFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  UserFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += " ) ";
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  UserFilterBuilder orderBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add(argFields);
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s ");
        }
    }
    return this;
  }

  UserFilterBuilder orderByDesc(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.orderByList.add("$argFields desc ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.orderByList.add(" $s desc ");
        }
    }
    return this;
  }

  UserFilterBuilder groupBy(var argFields) {
    if (argFields != null) {
      if (argFields is String)
        this.groupByList.add(" $argFields ");
      else
        for (String s in argFields) {
          if (s != null && s != "") this.groupByList.add(" $s ");
        }
    }
    return this;
  }

  UserField setField(UserField field, String colName, DbType dbtype) {
    field = new UserField(this);
    field.param = new DbParameter(
        dbType: dbtype,
        columnName: colName,
        wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
    return field;
  }

  UserField _id;
  UserField get id {
    _id = setField(_id, "id", DbType.integer);
    return _id;
  }
  UserField _password;
  UserField get password {
    _password = setField(_password, "password", DbType.text);
    return _password;
  }
  UserField _active;
  UserField get active {
    _active = setField(_active, "active", DbType.bool);
    return _active;
  }
  UserField _mobile_number;
  UserField get mobile_number {
    _mobile_number = setField(_mobile_number, "mobile_number", DbType.text);
    return _mobile_number;
  }
  UserField _api_token;
  UserField get api_token {
    _api_token = setField(_api_token, "api_token", DbType.text);
    return _api_token;
  }
  UserField _device_id;
  UserField get device_id {
    _device_id = setField(_device_id, "device_id", DbType.text);
    return _device_id;
  }
  UserField _created_at;
  UserField get created_at {
    _created_at = setField(_created_at, "created_at", DbType.text);
    return _created_at;
  }
  UserField _updated_at;
  UserField get updated_at {
    _updated_at = setField(_updated_at, "updated_at", DbType.text);
    return _updated_at;
  }


  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams.limit = _pagesize;
      qparams.offset = (_page - 1) * _pagesize;
    } else {
      qparams.limit = _pagesize;
      qparams.offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll("[", "")
              .replaceAll("]", "")
              .toString();
          whereString += param.whereString
              .replaceAll("{field}", param.columnName)
              .replaceAll("?", param.value);
          param.value = null;
        } else
          whereString +=
              param.whereString.replaceAll("{field}", param.columnName);
        switch (param.dbType) {
          case DbType.bool:
            if (param.value != null) param.value = param.value ? 1 : 0;
            break;
          default:
        }

        if (param.value != null) whereArguments.add(param.value);
        if (param.value2 != null) whereArguments.add(param.value2);
      } else
        whereString += param.whereString;
    }
    if (User._softDeleteActivated) {
      if (whereString != "")
        whereString = (!_getIsDeleted ? "ifnull(isDeleted,0)=0 AND" : "") +
            " ($whereString)";
      else if (!_getIsDeleted) whereString = "ifnull(isDeleted,0)=0";
    }

    if (whereString != "") qparams.whereString = whereString;
    qparams.whereArguments = whereArguments;
    qparams.groupBy = groupByList.join(',');
    qparams.orderBy = orderByList.join(',');
  }


  /// <summary>
  /// Deletes List<User> batch by query
  /// </summary>
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted</returns>
  Future<BoolResult> delete() async {
    _buildParameters();
    var r= BoolResult();
    if(User._softDeleteActivated)
      r = await _obj._mnUser.updateBatch(qparams,{"isDeleted":1});
    else
      r = await _obj._mnUser.delete(qparams);
    return r;
  }


  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    return _obj._mnUser.updateBatch(qparams, values);
  }

  /// This method always returns UserObj if exist, otherwise returns null
  /// <returns>List<User></returns>
  void toSingle(VoidCallback user(User o)) {
    _pagesize = 1;
    _buildParameters();
    var objFuture = _obj._mnUser.toList(qparams);
    objFuture.then((data) {
      if (data.length > 0)
        user(User.fromMap(data[0]));
      else
        user(null);
    });
  }


  /// This method always returns int.
  /// <returns>int</returns>
  Future<BoolResult> toCount(VoidCallback userCount (int c)) async {
    _buildParameters();
    qparams.selectColumns = ["COUNT(1) AS CNT"];
    var usersFuture = await _obj._mnUser.toList(qparams);
    int count = usersFuture[0]["CNT"];
    userCount (count);
    return BoolResult(success:count>0, successMessage: count>0? "toCount(): $count items found":"", errorMessage: count>0?"": "toCount(): no items found");
  }

  /// This method always returns List<User>.
  /// <returns>List<User></returns>
  void toList(VoidCallback userList (List<User> o)) async {

    _buildParameters();

    var usersFuture = _obj._mnUser.toList(qparams);

    List<User> usersData = new List<User>();
    usersFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        usersData.add(User.fromMap(data[i]));
      }
      userList (usersData);
      usersData = null;
    });
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int></returns>
  Future<List<int>> toListPrimaryKey(VoidCallback idList (List<int> o),
      [bool buildParameters=true]) async {
    if(buildParameters) _buildParameters();
    List<int> idData = new List<int>();
    qparams.selectColumns= ["id"];
    var idFuture = await _obj._mnUser.toList(qparams);

    int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]["id"]);
    }
    idList (idData);
    return idData;
  }

  void toListObject(VoidCallback listObject(List<dynamic> o)) async {
    _buildParameters();

    var objectFuture = _obj._mnUser.toList(qparams);

    List<dynamic> objectsData = new List<dynamic>();
    objectFuture.then((data) {
      int count = data.length;
      for (int i = 0; i < count; i++) {
        objectsData.add(data[i]);
      }
      listObject(objectsData);
      objectsData = null;
    });


  }

}
// endregion UserFilterBuilder




// region UserFields
class UserFields {
  static TableField _fId;
  static TableField get id {
    _fId = SqlSyntax.setField(_fId, "id", DbType.integer);
    return _fId;
  }
  static TableField _fPassword;
  static TableField get password {
    _fPassword = SqlSyntax.setField(_fPassword, "password", DbType.text);
    return _fPassword;
  }
  static TableField _fActive;
  static TableField get active {
    _fActive = SqlSyntax.setField(_fActive, "active", DbType.bool);
    return _fActive;
  }
  static TableField _fMobile_number;
  static TableField get mobile_number {
    _fMobile_number = SqlSyntax.setField(_fMobile_number, "mobile_number", DbType.text);
    return _fMobile_number;
  }
  static TableField _fApi_token;
  static TableField get api_token {
    _fApi_token = SqlSyntax.setField(_fApi_token, "api_token", DbType.text);
    return _fApi_token;
  }
  static TableField _fDevice_id;
  static TableField get device_id {
    _fDevice_id = SqlSyntax.setField(_fDevice_id, "device_id", DbType.text);
    return _fDevice_id;
  }
  static TableField _fCreated_at;
  static TableField get created_at {
    _fCreated_at = SqlSyntax.setField(_fCreated_at, "created_at", DbType.text);
    return _fCreated_at;
  }
  static TableField _fUpdated_at;
  static TableField get updated_at {
    _fUpdated_at = SqlSyntax.setField(_fUpdated_at, "updated_at", DbType.text);
    return _fUpdated_at;
  }

}
// endregion UserFields

//region UserManager
class UserManager extends SqfEntityProvider {
  static String _tableName = "user";
  static String _colId = "id";
  UserManager():super(AppDatabase(),tableName: _tableName, colId: _colId);
}
//endregion UserManager
